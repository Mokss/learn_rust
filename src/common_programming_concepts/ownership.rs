// rust сделал все очень просто и умно, но в тоже время, нужно привыкнуть к совершенно новой парадигме программирования
// он все такой же низкоуровневый и быстрый
// теория проста, все что покидает область видимости, то удаляетс из памяти
// у раста есть стек - это указатели или простые примитивы(строки не примитивы) и куча, для более сложных данных
// ну когда стек очищается - из кучи очищается данные
// ссылкой на не примтив может владеть только одна переменная
// по умолчанию присваивание != копирование, а по факту просто замена владельца от отдной переменной в другую
// сделано для того, чтобы у нас была только 1 точка входа к данным в куче, и мы всегда могли отслеживать указатель
// и после выхода его из области видимости, сразу очищать память, безопасно, даже не руками как это сделано в cpp с new

#[allow(dead_code)]
pub fn ownership() {
    // №2 после того, как мы получили ссылку, записали ее в s1
    let s1 = gives_ownership();

    // №3 объявили строку, и записаои ссылку в s2
    let s2 = String::from("hello");

    // №4 вызвали функцию и передали в нее строку s2
    // s2 удалили, этой переменной больше нет, если вывести в консоль, будет ошибка
    // мы передали владельца аргументу функции takes_and_gives_back
    let s3: String = takes_and_gives_back(s2);
    // №6 теперь владелец строки s3;

    print!("s1:{s1} and s3:{s3}");
}

// №1 мы здесь объявили строку, положили ее в кучу и сразу ссылку вернули из функции
// переменная some_string очистилась
fn gives_ownership() -> String {
    let some_string = String::from("yours"); 

    return some_string;
}

// №5 мы получили в аргументе ссылку на строку из s2, и сразу ее вернули, функция очистилась из стека
fn takes_and_gives_back(a_string: String) -> String {
    return a_string;
}


// еще раз все числовые типы, числа с плавающей точкой, boolean, char - это примитивы
// и там передачи владельца так таковой нет
// значения просто копируются в новые переменные при присвоении